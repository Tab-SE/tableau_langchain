import json
import requests
from typing import Dict
from langchain_tableau.utilities.utils import http_post


def get_datasource_query(luid):
    query = f"""
    query datasourceFieldInfo {{
        publishedDatasources(filter: {{ luid: "{luid}" }}) {{
          name
          description
          owner {{
            name
          }}
          fields {{
            name
            isHidden
            description
            descriptionInherited {{
              attribute
              value
            }}
            fullyQualifiedName
            __typename
            ... on AnalyticsField {{
              __typename
            }}
            ... on ColumnField {{
              dataCategory
              role
              dataType
              defaultFormat
              semanticRole
              aggregation
              aggregationParam
            }}
            ... on CalculatedField {{
              dataCategory
              role
              dataType
              defaultFormat
              semanticRole
              aggregation
              aggregationParam
              formula
              isAutoGenerated
              hasUserReference
            }}
            ... on BinField {{
              dataCategory
              role
              dataType
              formula
              binSize
            }}
            ... on GroupField {{
              dataCategory
              role
              dataType
              hasOther
            }}
            ... on CombinedSetField {{
              delimiter
              combinationType
            }}
          }}
        }}
      }}
    """

    return query


async def get_data_dictionary_async(api_key: str, domain: str, datasource_luid: str) -> Dict:
    full_url = f"{domain}/api/metadata/graphql"

    query = get_datasource_query(datasource_luid)

    payload = {
        "query": query,
        "variables": {}
    }

    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Tableau-Auth': api_key
    }

    response = await http_post(endpoint=full_url, headers=headers, payload=payload)

    # Check if the request was successful (status code 200)
    if response['status'] == 200:
        # Parse the response data
        response_data = response['data']
        if 'errors' in response_data:
            error_message = f"GraphQL errors: {response_data['errors']}"
            raise RuntimeError(error_message)

        json_data = response_data['data']['publishedDatasources'][0]

        # Keep the raw data as the primary source of truth
        raw_fields = json_data.get('fields', [])
        visible_fields = [f for f in raw_fields if not f.get('isHidden')]

        return {
            'datasource_name': json_data.get('name'),
            'datasource_description': json_data.get('description'),
            'datasource_owner': json_data.get('owner', {}).get('name'),
            'datasource_luid': datasource_luid,

            # Raw GraphQL data - let the LLM work with full fidelity
            'fields': visible_fields,

            # Minimal helpful additions without losing data
            'field_count': len(visible_fields),
            'field_names': [f['name'] for f in visible_fields],

            # Full raw response for power users
            'raw_graphql_response': json_data
        }
    else:
        error_message = (
            f"Failed to query Tableau's Metadata API. "
            f"Status code: {response['status']}. Response: {response['data']}"
        )
        raise RuntimeError(error_message)


def get_data_dictionary(api_key: str, domain: str, datasource_luid: str) -> Dict:
    full_url = f"{domain}/api/metadata/graphql"

    query = get_datasource_query(datasource_luid)

    payload = json.dumps({
        "query": query,
        "variables": {}
    })

    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-Tableau-Auth': api_key
    }

    response = requests.post(full_url, headers=headers, data=payload)
    response.raise_for_status()  # Raise an exception for bad status codes

    response_data = response.json()
    if 'errors' in response_data:
        error_message = f"GraphQL errors: {response_data['errors']}"
        raise RuntimeError(error_message)

    json_data = response_data['data']['publishedDatasources'][0]

    # Keep the raw data as the primary source of truth
    raw_fields = json_data.get('fields', [])
    visible_fields = [f for f in raw_fields if not f.get('isHidden')]

    return {
        'datasource_name': json_data.get('name'),
        'datasource_description': json_data.get('description'),
        'datasource_owner': json_data.get('owner', {}).get('name'),
        'datasource_luid': datasource_luid,

        # Raw GraphQL data - let the LLM work with full fidelity
        'fields': visible_fields,

        # Minimal helpful additions without losing data
        'field_count': len(visible_fields),
        'field_names': [f['name'] for f in visible_fields],

        # Full raw response for power users
        'raw_graphql_response': json_data
    }
