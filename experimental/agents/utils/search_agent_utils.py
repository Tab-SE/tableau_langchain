from typing import Dict, TypedDict, Optional
import os
import json

from IPython.display import Image, display
from experimental.agents.shared_state import get_datasource_luid

def _visualize_graph(graph):
    """
    Creates a mermaid visualization of the State Graph in .png format
    """

    # Attempt to generate and save PNG
    try:
        png_data = graph.get_graph().draw_mermaid_png()
        filename = "graph_visualization.png"
        with open(filename, "wb") as f:
            f.write(png_data)

        if os.path.exists(filename):
            file_size = os.path.getsize(filename)
            print(f"Agent Graph saved as '{filename}' | file size: {file_size} bytes")


            display(Image(png_data))
        else:
            print(f"Failed to create file '{filename}'")
    except Exception as e:
        print(f"Failed to generate PNG: {str(e)}")


async def stream_graph_updates(message: dict, graph):
    """
    This function streams responses from Agents to clients, such as chat interfaces, by processing
    user inputs and dynamically updating the conversation.

    The function takes a string input from the user and passes it to the state graph's streaming interface.
    It initiates a stream of events based on the provided user input, which is wrapped in a dictionary with
    a key "messages" containing a tuple of the user role and content.

    As each event is generated by the graph, the function iterates over the values returned. Within each event,
    it specifically looks for messages associated with the 'messages' key. The function extracts and prints the
    content of the last message in the sequence, which is assumed to be the assistant's most recent response.
    This enables a real-time conversation-like interaction where responses are generated and displayed immediately
    based on user input.

    if debugging is enabled (checked via an environment variable), it prints out the content of the last message
    for further inspection.

    Parameters:
    - message (dict): contains a string with the user_message and additional operating parameters
    - graph: a representation of the agents behavior and tool set

    Returns:
    - None. The function's primary side effect is to print the assistant's response to the console.
    """

    message_string = json.dumps(message['user_message'])

    tableau_credentials = message['agent_inputs']['tableau_credentials']
    
    # Always use the current datasource LUID (which may have been updated by the switch_datasource tool)
    datasource = message['agent_inputs']['datasource'].copy()  # Make a copy to avoid modifying the original
    # datasource['luid'] = current_datasource_luid  # Use the current LUID from tooling
    datasource['luid'] = get_datasource_luid()
    # print(f"Using datasource LUID: {current_datasource_luid}")
    
    # Print the current datasource LUID for debugging purposes
    print(f"Using datasource LUID: {get_datasource_luid()}")

    # this is how client apps should format their requests to the Agent API
    input_stream = {
        "messages": [("user", message_string)],
        "tableau_credentials": tableau_credentials,
        "datasource": datasource
    }
    
    # Add any additional agent inputs that might be present
    for key, value in message['agent_inputs'].items():
        if key not in ['user_message', 'tableau_credentials', 'datasource']:
            input_stream[key] = value

    # gets value DEBUG value or sets it to empty string, condition applies if string is empty or 0
    if os.environ.get("DEBUG", "") in ["0", ""]:
        # streams events from the agent graph started by the client input containing user queries
        async for event in graph.astream(input_stream):
            agent_output = event.get('agent')
            if event.get('agent'):
                agent_message = agent_output["messages"][0].content
                if len(agent_message) > 0:
                    print("\nAgent:")
                    print(f"{agent_message} \n")

    elif (os.environ["DEBUG"] == "1"):
        # display tableau credentials to prove access to the environment
        print('*** tableau_credentials ***', tableau_credentials)
        print('*** datasource ***', datasource)

        async for event in graph.astream(input_stream):
            print(f"*** EVENT *** type: {type(event)}")
            print(event)